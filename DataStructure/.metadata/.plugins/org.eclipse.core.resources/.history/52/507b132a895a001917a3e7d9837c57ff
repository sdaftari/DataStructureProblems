//Example: Closest BST value
//Input: root = [4,2,5,1,3], target = 3.714286
//
//    4
//   / \
//  2   5
// / \
//1   3
//
//Output: 4
// Closest k values
//Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.

package Easy;
import java.util.*;

public class ClosestBSTValue {
	
	public int closestValue(TreeNode root, double target) {
        int ret = root.val;   
        while(root != null)
        {
            if(Math.abs(target - root.val) < Math.abs(target - ret))
                ret = root.val;
              
            root = root.val > target? root.left: root.right;
        }     
        return ret;
    }
	
	// Closest k values
	public List<Integer> closestKValues(TreeNode root, double target, int k) 
	{
		List<Integer> res = new ArrayList<>();

		  Stack<Integer> s1 = new Stack<>(); // predecessors
		  Stack<Integer> s2 = new Stack<>(); // successors
	
		  inorder(root, target, false, s1);
		  inorder(root, target, true, s2);
		  
		  while (k-- > 0) 
		  {
		    if (s1.isEmpty())
		      res.add(s2.pop());
		    else if (s2.isEmpty())
		      res.add(s1.pop());
		    else if (Math.abs(s1.peek() - target) < Math.abs(s2.peek() - target))
		      res.add(s1.pop());
		    else
		      res.add(s2.pop());
		  }
		  
		  return res;
	}

		// inorder traversal
		void inorder(TreeNode root, double target, boolean reverse, Stack<Integer> stack) {
		  if (root == null) 
			  return;

		  inorder(reverse ? root.right : root.left, target, reverse, stack);
		  // early terminate, no need to traverse the whole tree
		  if ((reverse && root.val <= target) || (!reverse && root.val > target)) return;
		  // track the value of current node
		  stack.push(root.val);
		  inorder(reverse ? root.left : root.right, target, reverse, stack);
		}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
