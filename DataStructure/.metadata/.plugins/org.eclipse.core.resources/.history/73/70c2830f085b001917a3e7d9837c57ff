package Medium;

public class SortedIntersection {
	
	ListNode sortedIntersect(ListNode a, ListNode b) 
	{ 
	  ListNode dummy; 
	  ListNode tail = dummy; 
	  dummy.next = null; 
	   
	  /* Once one or the other list runs out -- we're done */
	  while (a != NULL && b != NULL) 
	  { 
	    if (a.data == b->data) 
	    { 
	       push((&tail->next), a->data); 
	       tail = tail->next; 
	       a = a->next; 
	       b = b->next; 
	    } 
	    else if (a->data < b->data) /* advance the smaller list */      
	       a = a->next; 
	    else
	       b = b->next; 
	  } 
	  return(dummy.next); 
	} 
	
	// Non sorted
	void getIntersection(ListNode head1, ListNode head2) 
    { 
		ListNode result = null; 
		ListNode t1 = head1; 
  
        // Traverse list1 and search each element of it in list2. 
        // If the element is present in list 2, then insert the 
        // element to result 
        while (t1 != null) 
        { 
            if (isPresent(head2, t1.val)) 
                push(t1.val); 
            t1 = t1.next; 
        } 
    }
	
	/* A utilty function that returns true if data is present 
    in linked list  else return false */
	 boolean isPresent (ListNode head, int data) 
	 { 
		 ListNode t = head; 
	     while (t != null) 
	     { 
	         if (t.data == data) 
	             return true; 
	         t = t.next; 
	     } 
	     return false; 
	 } 
	 
	 /*  Inserts a node at start of linked list */
	    void push(int new_data) 
	    { 
	        /* 1 & 2: Allocate the Node & 
	                  Put in the data*/
	        Node new_node = new Node(new_data); 
	  
	        /* 3. Make next of new Node as head */
	        new_node.next = head; 
	  
	        /* 4. Move the head to point to new Node */
	        head = new_node; 
	    } 

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
