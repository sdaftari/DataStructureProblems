//In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
//Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, 
//both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.
//Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
//We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  
//If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
//Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.

//Example 1:
//Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
//Output: 0

package Hard;
import java.util.*;

public class MinimizeMalwareSpread {
	
	public int minMalwareSpread(int[][] graph, int[] initial) 
	{
        Set<Integer> infected = new HashSet<>();
        
        //Get the list of affected nodes
        for(int initialInfected : initial)
            infected.add(initialInfected);
        
        int min = Integer.MAX_VALUE;
        int ans = 0;
        
        for(int ignore = 0; ignore < initial.length; ignore++)
        {
        	// Ignore one node from list and find out the spread
            int ignoreNumb = initial[ignore];
            infected.remove(ignoreNumb);
            
            int amount = spread(graph, infected);            
            
            // if amount is less, change the min value
            // Else if the amount is same, get the smaller index
            if(amount < min || (amount == min && initial[ignore] < ans))
            {
                ans = initial[ignore];
                min = amount;
            }
            
            infected.add(ignoreNumb);
        }
        return ans;
    }
    
    private int spread(int [][] graph, Set<Integer> infected)
    {
        Set<Integer> bad = new HashSet<>(infected);
        Queue<Integer> queue= new LinkedList<>();
        
        // First add all the infected nodes in the queue
        for(Integer initialInfected : infected)
        	queue.add(initialInfected);
        
        while(!queue.isEmpty())
        {
            Integer next = queue.remove();
            for(int j = 0; j < graph[next].length; j++)
            {
                if(graph[next][j] == 1 && !bad.contains(j))
                {
                    bad.add(j);
                    queue.add(j);
                }
            }
        }
        //return how many total were infected after spreading
        return bad.size();
    }
    
    // Malware SpreadII
    // We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  
    // Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
    public int minMalwareSpreadII(int[][] graph, int[] init) {
        Map<Integer, Set<Integer>> g = new HashMap<>();
        
        for(int i = 0; i < graph.length; i++) 
        {
        	// Create a map of connected components
            g.putIfAbsent(i, new HashSet<>());
            for(int j = 0; j < graph[0].length; j++) 
            {
                if(j != i && graph[i][j] == 1) 
                    g.get(i).add(j);
            }
        }

        // Create a set of infected nodes
        Set<Integer> infect = new HashSet<>();
        for(int i : init) 
        	infect.add(i);
        
        int max = -1, idx = -1;
        int[] v = new int[graph.length];
        for(int i : init) 
        {
            int count = 0;
            
            v[i] = 1;
            for(int child : g.get(i)) 
            {
                int ret = countSaved(g, child, v, infect);
                count += ret < 0 ? 0 : ret;
            }
            v[i] = 0;
            
            if(count > max) 
            {
                max = count;
                idx = i;
            } 
            else if(count == max && i < idx) 
                idx = i;
        }
        return idx;
    }
    
    int countSaved(Map<Integer, Set<Integer>> g, int root, int[] v, Set<Integer> infect) {
        if(v[root] == 1) 
        	return 0;
        if(infect.contains(root)) 
        	return -1;
        
        v[root] = 1;
        int count = 1;
        
        for(int child : g.get(root)) 
        {
            int ret = countSaved(g, child, v, infect);
            if(ret == -1) 
            {
                count = -1;
                break;
            }
            count += ret < 0 ? 0 : ret;
        }
        
        v[root] = 0;
        return count;
    }

	public static void main(String[] args) {
		int[][] graph = {{1,1,0},{1,1,1},{0,1,1}};
		int[] initial = {0,1};
		MinimizeMalwareSpread obj = new MinimizeMalwareSpread();
		System.out.println(obj.minMalwareSpreadII(graph, initial));
	}

	
}
